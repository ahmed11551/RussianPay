import Foundation
import CoreNFC
import CryptoKit

/// –≠–º—É–ª—è—Ç–æ—Ä NFC-—Ä–∏–¥–µ—Ä–∞ –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
class NFCReaderEmulator: NSObject, ObservableObject {
    
    // MARK: - Properties
    @Published var isReading = false
    @Published var connectionStatus: ConnectionStatus = .disconnected
    @Published var detectedTags: [NFCTagInfo] = []
    @Published var currentTransaction: TransactionInfo?
    
    private let cryptoEngine: CryptoEngine
    private let keyManager: KeyManager
    private var session: NFCNDEFReaderSession?
    private var currentTag: NFCTagInfo?
    
    // MARK: - Enums
    enum ConnectionStatus {
        case disconnected
        case connecting
        case connected
        case error(String)
    }
    
    // MARK: - Initialization
    init(cryptoEngine: CryptoEngine, keyManager: KeyManager) {
        self.cryptoEngine = cryptoEngine
        self.keyManager = keyManager
        super.init()
    }
    
    // MARK: - Public Methods
    
    /// –ó–∞–ø—É—Å–∫ —ç–º—É–ª—è—Ü–∏–∏ NFC-—Ä–∏–¥–µ—Ä–∞
    func startReading() {
        guard !isReading else { return }
        
        isReading = true
        connectionStatus = .connecting
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ NFC
        if NFCNDEFReaderSession.readingAvailable {
            startStandardNFCReading()
        } else {
            // –≠–º—É–ª—è—Ü–∏—è –±–µ–∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ NFC
            startEmulatedReading()
        }
    }
    
    /// –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —ç–º—É–ª—è—Ü–∏–∏
    func stopReading() {
        isReading = false
        connectionStatus = .disconnected
        
        session?.invalidate()
        session = nil
        currentTag = nil
    }
    
    /// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω–æ–π –º–µ—Ç–∫–∏
    func processDetectedTag(_ tag: NFCTagInfo) {
        currentTag = tag
        connectionStatus = .connected
        
        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ —Å–ø–∏—Å–æ–∫ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫
        if !detectedTags.contains(where: { $0.uid == tag.uid }) {
            detectedTags.append(tag)
        }
        
        // –ù–∞—á–∞–ª–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        startTransaction(with: tag)
    }
    
    /// –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    func completeTransaction(success: Bool) {
        guard let transaction = currentTransaction else { return }
        
        transaction.isCompleted = true
        transaction.isSuccessful = success
        transaction.endTime = Date()
        
        // –û—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—É—â–µ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        currentTransaction = nil
        currentTag = nil
        connectionStatus = .disconnected
    }
    
    // MARK: - Private Methods
    
    private func startStandardNFCReading() {
        session = NFCNDEFReaderSession(delegate: self, queue: nil, invalidateAfterFirstRead: false)
        session?.alertMessage = "–ü–æ–¥–Ω–µ—Å–∏—Ç–µ –∫–∞—Ä—Ç—É –∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É –¥–ª—è –æ–ø–ª–∞—Ç—ã"
        session?.begin()
    }
    
    private func startEmulatedReading() {
        // –≠–º—É–ª—è—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ —á—Ç–µ–Ω–∏—è –±–µ–∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ NFC
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            self.connectionStatus = .connected
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –º–µ—Ç–∫–∏
            let emulatedTag = self.createEmulatedTag()
            self.processDetectedTag(emulatedTag)
        }
    }
    
    private func createEmulatedTag() -> NFCTagInfo {
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –º–µ—Ç–∫–∏ —Å —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
        let uid = generateRandomUID()
        let atr = generateATR()
        
        return NFCTagInfo(
            uid: uid,
            atr: atr,
            cardType: .contactless,
            protocol: .iso14443A,
            isEmulated: true
        )
    }
    
    private func generateRandomUID() -> Data {
        var bytes = [UInt8](repeating: 0, count: 7)
        _ = SecRandomCopyBytes(kSecRandomDefault, 7, &bytes)
        return Data(bytes)
    }
    
    private func generateATR() -> Data {
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è ATR –¥–ª—è —ç–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–∞—Ä—Ç—ã
        return Data([0x3B, 0x8F, 0x80, 0x01, 0x80, 0x4F, 0x0C, 0xA0, 0x00, 0x00, 0x03, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00])
    }
    
    private func startTransaction(with tag: NFCTagInfo) {
        let transaction = TransactionInfo(
            tag: tag,
            startTime: Date(),
            amount: 0.0,
            merchantId: "com.russianpay.merchant",
            status: .initialized
        )
        
        currentTransaction = transaction
        
        // –ù–∞—á–∞–ª–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        authenticateTag(tag)
    }
    
    private func authenticateTag(_ tag: NFCTagInfo) {
        // –≠–º—É–ª—è—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            self.currentTransaction?.status = .authenticated
            print("üîê –ú–µ—Ç–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–∞: \(tag.uid.map { String(format: "%02X", $0) }.joined())")
        }
    }
    
    // MARK: - APDU Commands
    
    /// –û—Ç–ø—Ä–∞–≤–∫–∞ APDU –∫–æ–º–∞–Ω–¥—ã
    func sendAPDUCommand(_ apdu: Data) -> Data? {
        guard let tag = currentTag else { return nil }
        
        let command = parseAPDUCommand(apdu)
        
        switch command {
        case .select:
            return handleSelectCommand(apdu)
        case .readBinary:
            return handleReadBinaryCommand(apdu)
        case .getChallenge:
            return handleGetChallengeCommand(apdu)
        case .externalAuthenticate:
            return handleExternalAuthenticateCommand(apdu)
        case .internalAuthenticate:
            return handleInternalAuthenticateCommand(apdu)
        case .generateAC:
            return handleGenerateACCommand(apdu)
        case .getData:
            return handleGetDataCommand(apdu)
        case .putData:
            return handlePutDataCommand(apdu)
        case .updateBinary:
            return handleUpdateBinaryCommand(apdu)
        case .unknown:
            return createErrorResponse(.commandNotAllowed)
        }
    }
    
    private enum APDUCommand {
        case select
        case readBinary
        case getChallenge
        case externalAuthenticate
        case internalAuthenticate
        case generateAC
        case getData
        case putData
        case updateBinary
        case unknown
    }
    
    private func parseAPDUCommand(_ apdu: Data) -> APDUCommand {
        guard apdu.count >= 4 else { return .unknown }
        
        let cla = apdu[0]
        let ins = apdu[1]
        
        switch (cla, ins) {
        case (0x00, 0xA4): return .select
        case (0x00, 0xB0): return .readBinary
        case (0x00, 0x84): return .getChallenge
        case (0x00, 0x82): return .externalAuthenticate
        case (0x00, 0x88): return .internalAuthenticate
        case (0x80, 0xAE): return .generateAC
        case (0x80, 0xCA): return .getData
        case (0x80, 0xDA): return .putData
        case (0x00, 0xD6): return .updateBinary
        default: return .unknown
        }
    }
    
    private func handleSelectCommand(_ apdu: Data) -> Data {
        print("üìã –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã SELECT")
        return Data([0x90, 0x00])
    }
    
    private func handleReadBinaryCommand(_ apdu: Data) -> Data {
        print("üìñ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã READ BINARY")
        
        // –≠–º—É–ª—è—Ü–∏—è —á—Ç–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç—ã
        let cardData = createEmulatedCardData()
        return cardData + Data([0x90, 0x00])
    }
    
    private func handleGetChallengeCommand(_ apdu: Data) -> Data {
        print("üé≤ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã GET CHALLENGE")
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ challenge
        let challenge = cryptoEngine.generateRandomBytes(length: 8)
        return challenge + Data([0x90, 0x00])
    }
    
    private func handleExternalAuthenticateCommand(_ apdu: Data) -> Data {
        print("üîê –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã EXTERNAL AUTHENTICATE")
        
        // –≠–º—É–ª—è—Ü–∏—è –≤–Ω–µ—à–Ω–µ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        return Data([0x90, 0x00])
    }
    
    private func handleInternalAuthenticateCommand(_ apdu: Data) -> Data {
        print("üîê –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã INTERNAL AUTHENTICATE")
        
        // –≠–º—É–ª—è—Ü–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        let response = cryptoEngine.generateAuthenticationResponse()
        return response + Data([0x90, 0x00])
    }
    
    private func handleGenerateACCommand(_ apdu: Data) -> Data {
        print("üí≥ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã GENERATE AC")
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è Application Cryptogram
        let ac = cryptoEngine.generateApplicationCryptogram()
        return ac + Data([0x90, 0x00])
    }
    
    private func handleGetDataCommand(_ apdu: Data) -> Data {
        print("üìä –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã GET DATA")
        
        // –í–æ–∑–≤—Ä–∞—Ç –¥–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç—ã
        let cardData = createEmulatedCardData()
        return cardData + Data([0x90, 0x00])
    }
    
    private func handlePutDataCommand(_ apdu: Data) -> Data {
        print("üíæ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã PUT DATA")
        return Data([0x90, 0x00])
    }
    
    private func handleUpdateBinaryCommand(_ apdu: Data) -> Data {
        print("‚úèÔ∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã UPDATE BINARY")
        return Data([0x90, 0x00])
    }
    
    private func createEmulatedCardData() -> Data {
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç—ã
        var data = Data()
        
        // PAN (Primary Account Number)
        data.append(0x5A) // Tag for PAN
        data.append(0x10) // Length
        data.append(contentsOf: "1234567890123456".utf8)
        
        // Expiry Date
        data.append(0x5F, 0x24) // Tag for Expiry Date
        data.append(0x03) // Length
        data.append(contentsOf: "12/25".utf8)
        
        // Cardholder Name
        data.append(0x5F, 0x20) // Tag for Cardholder Name
        data.append(0x0C) // Length
        data.append(contentsOf: "IVAN IVANOV".utf8)
        
        return data
    }
    
    private func createErrorResponse(_ error: APDUError) -> Data {
        return Data([error.sw1, error.sw2])
    }
    
    private enum APDUError {
        case commandNotAllowed
        case fileNotFound
        case securityStatusNotSatisfied
        case incorrectParameters
        
        var sw1: UInt8 {
            switch self {
            case .commandNotAllowed: return 0x69
            case .fileNotFound: return 0x6A
            case .securityStatusNotSatisfied: return 0x69
            case .incorrectParameters: return 0x6A
            }
        }
        
        var sw2: UInt8 {
            switch self {
            case .commandNotAllowed: return 0x82
            case .fileNotFound: return 0x82
            case .securityStatusNotSatisfied: return 0x82
            case .incorrectParameters: return 0x86
            }
        }
    }
}

// MARK: - NFCNDEFReaderSessionDelegate
extension NFCReaderEmulator: NFCNDEFReaderSessionDelegate {
    
    func readerSession(_ session: NFCNDEFReaderSession, didInvalidateWithError error: Error) {
        DispatchQueue.main.async {
            self.connectionStatus = .error(error.localizedDescription)
            self.isReading = false
        }
    }
    
    func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö NFC-–º–µ—Ç–æ–∫
        for message in messages {
            processNDEFMessage(message)
        }
    }
    
    private func processNDEFMessage(_ message: NFCNDEFMessage) {
        for record in message.records {
            if let payload = String(data: record.payload, encoding: .utf8) {
                print("NFC Payload: \(payload)")
                
                // –°–æ–∑–¥–∞–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –º–µ—Ç–∫–µ
                let tagInfo = NFCTagInfo(
                    uid: generateRandomUID(),
                    atr: generateATR(),
                    cardType: .contactless,
                    protocol: .iso14443A,
                    isEmulated: false
                )
                
                processDetectedTag(tagInfo)
            }
        }
    }
}

// MARK: - Supporting Types
struct NFCTagInfo: Identifiable, Equatable {
    let id = UUID()
    let uid: Data
    let atr: Data
    let cardType: CardType
    let protocol: NFCProtocol
    let isEmulated: Bool
    
    enum CardType {
        case contactless
        case dualInterface
        case emv
        case mir
    }
    
    enum NFCProtocol {
        case iso14443A
        case iso14443B
        case feliCa
        case iso15693
    }
    
    static func == (lhs: NFCTagInfo, rhs: NFCTagInfo) -> Bool {
        return lhs.uid == rhs.uid
    }
}

struct TransactionInfo {
    let tag: NFCTagInfo
    let startTime: Date
    var endTime: Date?
    var amount: Double
    let merchantId: String
    var status: TransactionStatus
    var isCompleted: Bool = false
    var isSuccessful: Bool = false
    
    enum TransactionStatus {
        case initialized
        case authenticated
        case processing
        case completed
        case failed
    }
}
